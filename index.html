<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SOR vs CG — Transporte (UMSA) | Carlos & Genesis</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- MathJax for LaTeX rendering (lightweight config) -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
  <style>
    @keyframes fadeUp { from{opacity:0; transform:translateY(8px)} to{opacity:1; transform:translateY(0)} }
    .fade-up { animation: fadeUp .6s ease-out both; }
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button { opacity: .35; }
  </style>
</head>
<body class="bg-slate-950 text-slate-100 selection:bg-indigo-500/30">
  <!-- Header -->
  <header class="sticky top-0 z-40 backdrop-blur bg-slate-950/70 border-b border-slate-800">
    <div class="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="h-10 w-10 rounded-2xl bg-gradient-to-br from-indigo-500 to-fuchsia-500 shadow-lg shadow-indigo-500/30"></div>
        <div>
          <h1 class="text-xl sm:text-2xl font-bold tracking-tight">SOR vs CG — Planificación de Transporte</h1>
          <p class="text-xs sm:text-sm text-slate-300">Comparador interactivo de métodos iterativos (UMSA · Carrera de Informática)</p>
        </div>
      </div>
      <div class="text-right text-xs sm:text-sm leading-tight">
        <div class="font-semibold">Carlos Manuel Miranda Aguirre</div>
        <div class="font-semibold">Genesis Jalid Tapia Cortez</div>
      </div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-4 py-6 space-y-8">
    <!-- Problem setup card -->
    <section class="fade-up rounded-2xl border border-slate-800 bg-slate-900/60 p-5 shadow-lg shadow-indigo-500/5">
      <div class="flex flex-col lg:flex-row gap-6">
        <!-- Matrix + b -->
        <div class="flex-1">
          <div class="flex items-center justify-between mb-3">
            <h2 class="text-lg font-semibold">Modelo $A\,x=b$ — Ejemplo de Transporte</h2>
            <div class="flex gap-2">
              <button id="btnLoadTransport" class="px-3 py-1.5 text-sm rounded-lg bg-indigo-600 hover:bg-indigo-500 transition">Cargar ejemplo</button>
              <button id="btnClear" class="px-3 py-1.5 text-sm rounded-lg bg-slate-700 hover:bg-slate-600 transition">Limpiar</button>
            </div>
          </div>

          <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
            <!-- A matrix -->
            <div class="sm:col-span-2">
              <div class="mb-1 text-sm text-slate-300">Matriz de consumos $A$ (3×3)</div>
              <div id="Ainputs" class="grid grid-cols-3 gap-2"></div>
              <div class="mt-2 text-xs text-slate-400">Filas = recursos (Conductor, Combustible, Mantenimiento) · Columnas = variables (C, M, L)</div>
            </div>
            <!-- b vector -->
            <div>
              <div class="mb-1 text-sm text-slate-300">Recursos disponibles $b$ (3×1)</div>
              <div id="Binputs" class="grid grid-cols-1 gap-2"></div>
              <div class="mt-2 text-xs text-slate-400">$b=[\text{Horas},\ \text{Combustible},\ \text{Mantenimiento}]^\top$</div>
            </div>
          </div>

          <!-- Row scaling (cambio de unidades por recurso) -->
          <div class="mt-4 rounded-xl border border-slate-800 p-3 bg-slate-900/70">
            <div class="flex items-center justify-between">
              <div class="text-sm font-medium">Cambio de unidades (escalado de ecuaciones)</div>
              <label class="inline-flex items-center gap-2 text-sm">
                <input id="cbxScale" type="checkbox" class="size-4 rounded border-slate-600" />
                <span>Activar</span>
              </label>
            </div>
            <div id="scalePanel" class="grid grid-cols-1 sm:grid-cols-3 gap-3 mt-3 opacity-40 pointer-events-none">
              <div>
                <label class="text-xs text-slate-300">Escala Horas de Conductor</label>
                <input id="scaleR1" type="number" step="0.1" value="1" class="w-full mt-1 px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700" />
              </div>
              <div>
                <label class="text-xs text-slate-300">Escala Combustible</label>
                <input id="scaleR2" type="number" step="0.1" value="1" class="w-full mt-1 px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700" />
              </div>
              <div>
                <label class="text-xs text-slate-300">Escala Mantenimiento</label>
                <input id="scaleR3" type="number" step="0.1" value="1" class="w-full mt-1 px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700" />
              </div>
            </div>
            <p class="mt-2 text-xs text-slate-400">Multiplica cada ecuación por un factor (cambia unidades). La solución $x$ debe mantenerse; la convergencia puede variar.</p>
          </div>
        </div>

        <!-- Parameters & actions -->
        <div class="w-full lg:w-80">
          <div class="rounded-xl border border-slate-800 bg-slate-900/70 p-4 space-y-4">
            <h3 class="font-semibold">Parámetros</h3>
            <div class="space-y-2">
              <div class="text-sm text-slate-300">SOR</div>
              <div class="flex items-center gap-3">
                <label class="text-xs w-16">$\omega$</label>
                <input id="omega" type="range" min="0.5" max="1.95" step="0.01" value="1.20" class="w-full" />
                <span id="omegaVal" class="text-sm tabular-nums w-12 text-right">1.20</span>
              </div>
              <div class="grid grid-cols-2 gap-3">
                <div>
                  <label class="text-xs">tol</label>
                  <input id="tolSOR" type="number" step="1e-8" value="1e-8" class="w-full mt-1 px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700" />
                </div>
                <div>
                  <label class="text-xs">max it</label>
                  <input id="maxItSOR" type="number" value="1000" class="w-full mt-1 px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700" />
                </div>
              </div>
            </div>

            <div class="pt-2 border-t border-slate-800 space-y-2">
              <div class="text-sm text-slate-300">CG (sobre $A^\top A$)</div>
              <div class="grid grid-cols-2 gap-3">
                <div>
                  <label class="text-xs">tol</label>
                  <input id="tolCG" type="number" step="1e-8" value="1e-8" class="w-full mt-1 px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700" />
                </div>
                <div>
                  <label class="text-xs">max it</label>
                  <input id="maxItCG" type="number" value="1000" class="w-full mt-1 px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700" />
                </div>
              </div>
            </div>

            <div class="pt-2 border-t border-slate-800 grid grid-cols-2 gap-3">
              <button id="btnSolveBoth" class="col-span-2 px-3 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500 shadow-md shadow-indigo-500/30 transition">Resolver Ambos</button>
              <button id="btnSolveSOR" class="px-3 py-2 rounded-lg bg-fuchsia-600/90 hover:bg-fuchsia-600 transition">Solo SOR</button>
              <button id="btnSolveCG" class="px-3 py-2 rounded-lg bg-emerald-600/90 hover:bg-emerald-600 transition">Solo CG</button>
            </div>
            <div class="text-xs text-slate-400">Tip: si SOR no converge, intenta bajar $\omega$ o reescalar ecuaciones.</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Results summary -->
    <section class="fade-up grid md:grid-cols-2 gap-6">
      <!-- Solutions -->
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-5 shadow-lg shadow-indigo-500/5">
        <h3 class="text-lg font-semibold mb-2">Soluciones comparadas</h3>
        <div class="overflow-x-auto">
          <table class="min-w-full text-sm">
            <thead>
              <tr class="text-slate-300">
                <th class="text-left py-2">Método</th>
                <th class="text-right">$x_C$</th>
                <th class="text-right">$x_M$</th>
                <th class="text-right">$x_L$</th>
                <th class="text-right">iter</th>
                <th class="text-right">$\lVert r\rVert_2$</th>
                <th class="text-right">ms</th>
              </tr>
            </thead>
            <tbody id="tblSolutions" class="divide-y divide-slate-800"></tbody>
          </table>
        </div>
      </div>

      <!-- Validation -->
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-5 shadow-lg shadow-indigo-500/5">
        <h3 class="text-lg font-semibold mb-2">Validación $A\,x$ vs $b$</h3>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <div class="text-sm mb-1">$A\,x_{SOR}$</div>
            <ul id="valSOR" class="text-sm space-y-1 text-slate-300"></ul>
          </div>
          <div>
            <div class="text-sm mb-1">$A\,x_{CG}$</div>
            <ul id="valCG" class="text-sm space-y-1 text-slate-300"></ul>
          </div>
        </div>
        <p class="mt-3 text-xs text-slate-400">Mostramos $A\,x$ para comparar con $b$ (residuo pequeño = buen ajuste).</p>
      </div>
    </section>

    <!-- Charts -->
    <section class="fade-up grid lg:grid-cols-2 gap-6">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-5">
        <h3 class="font-semibold mb-2">Convergencia — $\lVert r_k\rVert_2$ (Original: $r=b-Ax$)</h3>
        <canvas id="residualChart" height="160"></canvas>
        <div class="mt-3 text-xs sm:text-sm text-slate-300 space-y-1">
          <div class="font-medium">¿Cómo leer este gráfico?</div>
          <ul class="list-disc pl-5 space-y-1">
            <li>Cada punto es una iteración k. Comparas SOR (magenta) y CG (verde).</li>
            <li>El eje Y es <strong>logarítmico</strong>: una caída grande significa que el error <code>||r_k||_2 = ||b − A·x_k||_2</code> se reduce en varios órdenes de magnitud.</li>
            <li>Objetivo: que <code>||r_k||_2</code> baje por <em>debajo</em> de tu tolerancia (p. ej., <code>1e-8</code>).</li>
            <li>Si la curva baja y luego se “aplana” cerca de cero ⇒ <strong>convergió</strong>. Si se estanca o sube ⇒ baja ω o activa el <em>escalado por filas</em>.</li>
            <li>La curva que llega antes a la tolerancia usa menos iteraciones ⇒ <strong>método más eficiente</strong> en este sistema.</li>
          </ul>
        </div>
      </div>
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-5">
        <h3 class="font-semibold mb-2">Componentes $x$ por iteración — SOR</h3>
        <canvas id="componentsSORChart" height="160"></canvas>
        <div class="mt-3 text-xs sm:text-sm text-slate-300 space-y-1">
          <div class="font-medium">¿Cómo leer este gráfico?</div>
          <ul class="list-disc pl-5 space-y-1">
            <li>Evolución de <code>x_C</code>, <code>x_M</code> y <code>x_L</code> por iteración de <strong>SOR</strong>.</li>
            <li>Cuando las tres curvas se vuelven casi horizontales ⇒ <strong>estabilización</strong>.</li>
            <li>Oscilaciones grandes ⇒ ω demasiado alto. Prueba con 1.0–1.2 o reescala ecuaciones.</li>
          </ul>
        </div>
      </div>
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-5 lg:col-span-2">
        <h3 class="font-semibold mb-2">Componentes $x$ por iteración — CG</h3>
        <canvas id="componentsCGChart" height="160"></canvas>
        <div class="mt-3 text-xs sm:text-sm text-slate-300 space-y-1">
          <div class="font-medium">¿Cómo leer este gráfico?</div>
          <ul class="list-disc pl-5 space-y-1">
            <li>Igual que el anterior, pero para <strong>CG</strong> (sobre <code>AᵀA</code>).</li>
            <li>Suele llegar en menos iteraciones y con trayectorias más directas.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Iteration logs -->
    <section class="fade-up grid md:grid-cols-2 gap-6">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-5">
        <details open>
          <summary class="cursor-pointer font-semibold">Detalle de iteraciones — SOR</summary>
          <div class="overflow-x-auto mt-3 max-h-72 overflow-y-auto pr-2">
            <table class="min-w-full text-xs">
              <thead>
                <tr class="text-slate-300">
                  <th class="text-left py-1">k</th>
                  <th class="text-right">$x_C$</th>
                  <th class="text-right">$x_M$</th>
                  <th class="text-right">$x_L$</th>
                  <th class="text-right">$\lVert r\rVert_2$</th>
                  <th class="text-right">$\lVert\Delta x\rVert_\infty$</th>
                </tr>
              </thead>
              <tbody id="tblSOR" class="divide-y divide-slate-800"></tbody>
            </table>
          </div>
        </details>
      </div>
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-5">
        <details open>
          <summary class="cursor-pointer font-semibold">Detalle de iteraciones — CG</summary>
          <div class="overflow-x-auto mt-3 max-h-72 overflow-y-auto pr-2">
            <table class="min-w-full text-xs">
              <thead>
                <tr class="text-slate-300">
                  <th class="text-left py-1">k</th>
                  <th class="text-right">$x_C$</th>
                  <th class="text-right">$x_M$</th>
                  <th class="text-right">$x_L$</th>
                  <th class="text-right">$\lVert r\rVert_2$</th>
                  <th class="text-right">$\alpha$</th>
                  <th class="text-right">$\beta$</th>
                </tr>
              </thead>
              <tbody id="tblCG" class="divide-y divide-slate-800"></tbody>
            </table>
          </div>
        </details>
      </div>
    </section>

    <!-- Explanations -->
    <section class="fade-up rounded-2xl border border-slate-800 bg-slate-900/60 p-5">
      <h3 class="text-lg font-semibold mb-2">Explicación rápida</h3>
      <div class="grid md:grid-cols-2 gap-6 text-sm text-slate-300">
        <div>
          <h4 class="font-semibold mb-1">SOR (Sobre-Relajación Sucesiva)</h4>
          <p class="mb-2">Actualiza variable por variable con un factor $\omega$ que puede acelerar la convergencia.</p>
          <p class="p-3 rounded-lg bg-slate-800/70 border border-slate-700">$$x_i^{(k+1)}=(1-\omega)x_i^{(k)}+\frac{\omega}{a_{ii}}\Big(b_i-\sum_{j<i}a_{ij}x_j^{(k+1)}-\sum_{j>i}a_{ij}x_j^{(k)}\Big).$$</p>
          <p class="text-xs text-slate-400">Si no converge, reduce $\omega$ o reescala ecuaciones.</p>
        </div>
        <div>
          <h4 class="font-semibold mb-1">CG (Gradiente Conjugado)</h4>
          <p class="mb-2">Trabajamos sobre $M=A^\top A$ y $c=A^\top b$ (SPD). Comparamos el residuo respecto a $A$.</p>
          <p class="p-3 rounded-lg bg-slate-800/70 border border-slate-700">$$\alpha_k=\frac{r_k^\top r_k}{p_k^\top M p_k},\qquad \beta_k=\frac{r_{k+1}^\top r_{k+1}}{r_k^\top r_k}.$$</p>
          <p class="text-xs text-slate-400">Residuo original: $r=b-Ax$.</p>
        </div>
      </div>
    </section>

    <footer class="text-center text-xs text-slate-400 py-8">
      UMSA — Carrera de Informática · Hecho con ❤️ por Carlos & Genesis · 2025
    </footer>
  </main>

  <script>
    // ===================== Utility helpers =====================
    const $ = (q) => document.querySelector(q);

    function buildInputs(){
      const Ahost = document.querySelector('#Ainputs');
      const Bhost = document.querySelector('#Binputs');
      Ahost.innerHTML = '';
      Bhost.innerHTML = '';
      for (let i=0;i<9;i++){
        const input = document.createElement('input');
        input.type = 'number'; input.step = '0.01'; input.value = '0';
        input.className = 'w-full px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-indigo-500/40';
        input.dataset.pos = i;
        Ahost.appendChild(input);
      }
      for (let i=0;i<3;i++){
        const input = document.createElement('input');
        input.type = 'number'; input.step = '0.01'; input.value = '0';
        input.className = 'w-full px-3 py-2 rounded-lg bg-slate-800/70 border border-slate-700 focus:outline-none focus:ring-2 focus:ring-indigo-500/40';
        input.dataset.pos = i;
        Bhost.appendChild(input);
      }
    }

    function getMatrixA(){
      const inputs = Array.from(document.querySelector('#Ainputs').children);
      const A = [[0,0,0],[0,0,0],[0,0,0]];
      inputs.forEach((el,idx)=>{ const r=Math.floor(idx/3), c=idx%3; A[r][c] = parseFloat(el.value||'0'); });
      return A;
    }
    function getVectorB(){
      const inputs = Array.from(document.querySelector('#Binputs').children);
      return inputs.map(el=> parseFloat(el.value||'0'));
    }
    function setMatrixA(A){
      const inputs = Array.from(document.querySelector('#Ainputs').children);
      inputs.forEach((el,idx)=>{ const r=Math.floor(idx/3), c=idx%3; el.value = (A[r]?.[c] ?? 0); });
    }
    function setVectorB(b){
      const inputs = Array.from(document.querySelector('#Binputs').children);
      inputs.forEach((el,idx)=> el.value = (b[idx] ?? 0));
    }

    // Linear algebra helpers
    const clone = (m) => JSON.parse(JSON.stringify(m));
    const dot = (u,v) => u.reduce((s,ui,i)=> s + ui*v[i], 0);
    const norm2 = (u) => Math.sqrt(dot(u,u));
    const normInf = (u) => u.reduce((mx,ui)=> Math.max(mx, Math.abs(ui)), 0);

    function Ax(A, x) { return A.map(row => dot(row, x)); }
    function AT(A) { return [0,1,2].map(c => [A[0][c], A[1][c], A[2][c]]); }
    function matMul(A,B) {
      const R = [ [0,0,0], [0,0,0], [0,0,0] ];
      for(let i=0;i<3;i++){
        for(let j=0;j<3;j++){
          let s=0; for(let k=0;k<3;k++) s += A[i][k]*B[k][j];
          R[i][j]=s;
        }
      }
      return R;
    }
    function ATx(A, x){ const ATm = AT(A); return ATm.map(row => dot(row, x)); }

    function sub(u,v){ return u.map((ui,i)=> ui - v[i]); }
    function add(u,v){ return u.map((ui,i)=> ui + v[i]); }
    function scl(u,a){ return u.map(ui => a*ui); }

    function applyRowScaling(A,b,s1,s2,s3){
      const S = [s1,s2,s3];
      const A2 = clone(A); const b2 = b.slice();
      for(let i=0;i<3;i++){ for(let j=0;j<3;j++) A2[i][j]*=S[i]; b2[i]*=S[i]; }
      return {A2,b2};
    }

    // ===================== Solvers =====================
    function SOR(A, b, {omega=1.2, tol=1e-8, maxIt=1000}={}){
      const t0 = performance.now();
      const n=3; let x = [0,0,0];
      const xs = []; const resA = []; const deltas = [];
      for(let k=0;k<maxIt;k++){
        const xold = x.slice();
        for(let i=0;i<n;i++){
          const aii = A[i][i];
          if (Math.abs(aii) < 1e-14) return {x:xold, it:k, residuals:resA, xs, deltas, time: performance.now()-t0, diverged:true, reason:'a_ii≈0'};
          let s1=0, s2=0; for(let j=0;j<i;j++) s1 += A[i][j]*x[j]; for(let j=i+1;j<n;j++) s2 += A[i][j]*xold[j];
          const xgs = (b[i] - s1 - s2)/aii; x[i] = (1-omega)*xold[i] + omega*xgs;
        }
        const r = sub(b, Ax(A,x));
        xs.push(x.slice()); resA.push(norm2(r)); deltas.push(normInf(sub(x,xold)));
        if (deltas.at(-1) <= tol || resA.at(-1) <= tol) return {x, it:k+1, residuals:resA, xs, deltas, time: performance.now()-t0, diverged:false};
        if (k>5 && resA[k] > 1e12) return {x:x.slice(), it:k+1, residuals:resA, xs, deltas, time: performance.now()-t0, diverged:true, reason:'overflow'};
      }
      return {x, it:resA.length, residuals:resA, xs, deltas, time: performance.now()-t0, diverged:false, reason:'maxIt'};
    }

    function CG_on_normal_eq(A, b, {tol=1e-8, maxIt=1000}={}){
      const t0 = performance.now();
      const ATm = AT(A); const M = matMul(ATm, A); const c = ATx(A, b);
      let x = [0,0,0]; let r = sub(c, Ax(M,x)); let p = r.slice();
      const xs=[]; const resA=[]; const alphas=[]; const betas=[];
      for(let k=0;k<maxIt;k++){
        const Mp = Ax(M,p); const rr = dot(r,r); const denom = dot(p, Mp);
        if (Math.abs(denom) < 1e-18) break;
        const alpha = rr / denom; x = add(x, scl(p, alpha));
        const rNew = sub(r, scl(Mp, alpha)); const beta = dot(rNew,rNew)/rr; p = add(rNew, scl(p, beta)); r = rNew;
        const rA = sub(b, Ax(A,x)); xs.push(x.slice()); resA.push(norm2(rA)); alphas.push(alpha); betas.push(beta);
        if (resA.at(-1) <= tol) break;
      }
      return {x, it: xs.length, residuals: resA, xs, alphas, betas, time: performance.now()-t0};
    }

    // ===================== UI Updates =====================
    let chartResidual=null, chartXSOR=null, chartXCG=null;

    const fmt=(x,d=6)=> (isFinite(x)? Number.parseFloat(x).toFixed(d).replace(/\.0+$/,'') : '—');

    function updateSolutionsTable(sor, cg){
      const host = document.querySelector('#tblSolutions'); host.innerHTML = '';
      if (sor){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="py-2 font-medium text-fuchsia-300">SOR</td>
          <td class="text-right">${fmt(sor.x[0],4)}</td>
          <td class="text-right">${fmt(sor.x[1],4)}</td>
          <td class="text-right">${fmt(sor.x[2],4)}</td>
          <td class="text-right">${sor.it}</td>
          <td class="text-right">${sor.residuals.length? fmt(sor.residuals.at(-1),3):'—'}</td>
          <td class="text-right">${fmt(sor.time,2)}</td>`;
        host.appendChild(tr);
      }
      if (cg){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="py-2 font-medium text-emerald-300">CG</td>
          <td class="text-right">${fmt(cg.x[0],4)}</td>
          <td class="text-right">${fmt(cg.x[1],4)}</td>
          <td class="text-right">${fmt(cg.x[2],4)}</td>
          <td class="text-right">${cg.it}</td>
          <td class="text-right">${cg.residuals.length? fmt(cg.residuals.at(-1),3):'—'}</td>
          <td class="text-right">${fmt(cg.time,2)}</td>`;
        host.appendChild(tr);
      }
    }

    function updateValidation(A,b,sor,cg){
      function listFor(x){
        if (!x) return '<li class="text-slate-500">—</li>';
        const Axv = Ax(A,x.x);
        return Axv.map((val,i)=>{
          const err = Math.abs(val - b[i]);
          return `<li>fila ${i+1}: <span class="text-slate-2
00">${fmt(val,6)}</span> · b=${fmt(b[i],6)} · error=${fmt(err,2)}</li>`
        }).join('');
      }
      document.querySelector('#valSOR').innerHTML = listFor(sor);
      document.querySelector('#valCG').innerHTML = listFor(cg);
    }

    function buildResidualChart(sor, cg){
      const ctx = document.querySelector('#residualChart');
      const len = Math.max(sor?.residuals.length||0, cg?.residuals.length||0);
      const labels = Array.from({length: len}, (_,i)=> i+1);
      const tolLine = Math.min(parseFloat(document.querySelector('#tolSOR').value||'1e-8'), parseFloat(document.querySelector('#tolCG').value||'1e-8'));
      const data = {
        labels,
        datasets: [
          ...(sor? [{ label: 'SOR', data: sor.residuals, borderColor: 'rgba(217,70,239,1)', backgroundColor:'rgba(217,70,239,.15)', borderWidth:2, pointRadius:0, tension:.25 }] : []),
          ...(cg? [{ label: 'CG', data: cg.residuals, borderColor: 'rgba(16,185,129,1)', backgroundColor:'rgba(16,185,129,.15)', borderWidth:2, pointRadius:0, tension:.25 }] : []),
          { label: 'Tolerancia', data: labels.map(()=> tolLine), borderColor: 'rgba(148,163,184,1)', borderDash:[6,4], pointRadius:0, borderWidth:1.5 }
        ]
      };
      const opt = {
        responsive: true,
        scales: {
          y: { type: 'logarithmic', beginAtZero: false, ticks: { color:'#cbd5e1' }, grid: {color:'#1f2937'} },
          x: { ticks: { color:'#cbd5e1' }, grid: {color:'#1f2937'} }
        },
        plugins: { legend: { labels: { color:'#e2e8f0' } } }
      };
      if (chartResidual) chartResidual.destroy();
      chartResidual = new Chart(ctx, { type:'line', data, options: opt });
    }

    function buildXCharts(sor, cg){
      // SOR components
      const ctx1 = document.querySelector('#componentsSORChart');
      if (chartXSOR) chartXSOR.destroy();
      if (sor && sor.xs.length){
        const labels = sor.xs.map((_,i)=>i+1);
        const xc = sor.xs.map(v=>v[0]);
        const xm = sor.xs.map(v=>v[1]);
        const xl = sor.xs.map(v=>v[2]);
        chartXSOR = new Chart(ctx1, {
          type: 'line',
          data: { labels, datasets: [
            {label:'x_C', data: xc, borderColor:'rgba(129,140,248,1)', backgroundColor:'rgba(129,140,248,.15)', borderWidth:2, pointRadius:0, tension:.25},
            {label:'x_M', data: xm, borderColor:'rgba(59,130,246,1)', backgroundColor:'rgba(59,130,246,.15)', borderWidth:2, pointRadius:0, tension:.25},
            {label:'x_L', data: xl, borderColor:'rgba(236,72,153,1)', backgroundColor:'rgba(236,72,153,.15)', borderWidth:2, pointRadius:0, tension:.25},
          ] },
          options: { responsive:true, plugins:{ legend:{ labels:{ color:'#e2e8f0' } } }, scales:{ y:{ ticks:{ color:'#cbd5e1' }, grid:{color:'#1f2937'} }, x:{ ticks:{ color:'#cbd5e1' }, grid:{color:'#1f2937'} } } }
        });
      } else { ctx1.getContext('2d').clearRect(0,0,ctx1.width,ctx1.height); }

      // CG components
      const ctx2 = document.querySelector('#componentsCGChart');
      if (chartXCG) chartXCG.destroy();
      if (cg && cg.xs.length){
        const labels = cg.xs.map((_,i)=>i+1);
        const xc = cg.xs.map(v=>v[0]);
        const xm = cg.xs.map(v=>v[1]);
        const xl = cg.xs.map(v=>v[2]);
        chartXCG = new Chart(ctx2, {
          type: 'line',
          data: { labels, datasets: [
            {label:'x_C', data: xc, borderColor:'rgba(129,140,248,1)', backgroundColor:'rgba(129,140,248,.15)', borderWidth:2, pointRadius:0, tension:.25},
            {label:'x_M', data: xm, borderColor:'rgba(59,130,246,1)', backgroundColor:'rgba(59,130,246,.15)', borderWidth:2, pointRadius:0, tension:.25},
            {label:'x_L', data: xl, borderColor:'rgba(236,72,153,1)', backgroundColor:'rgba(236,72,153,.15)', borderWidth:2, pointRadius:0, tension:.25},
          ] },
          options: { responsive:true, plugins:{ legend:{ labels:{ color:'#e2e8f0' } } }, scales:{ y:{ ticks:{ color:'#cbd5e1' }, grid:{color:'#1f2937'} }, x:{ ticks:{ color:'#cbd5e1' }, grid:{color:'#1f2937'} } } }
        });
      } else { ctx2.getContext('2d').clearRect(0,0,ctx2.width,ctx2.height); }
    }

    function fillIterationTables(sor, cg){
      const tbSOR = document.querySelector('#tblSOR');
      const tbCG = document.querySelector('#tblCG');
      tbSOR.innerHTML = '';
      tbCG.innerHTML = '';
      if (sor){
        sor.xs.forEach((v,k)=>{
          const tr = document.createElement('tr');
          const r = sor.residuals[k] ?? NaN;
          const d = sor.deltas[k] ?? NaN;
          tr.innerHTML = `
            <td class="py-1">${k+1}</td>
            <td class="text-right">${fmt(v[0],6)}</td>
            <td class="text-right">${fmt(v[1],6)}</td>
            <td class="text-right">${fmt(v[2],6)}</td>
            <td class="text-right">${fmt(r,3)}</td>
            <td class="text-right">${fmt(d,3)}</td>`;
          tbSOR.appendChild(tr);
        });
      }
      if (cg){
        cg.xs.forEach((v,k)=>{
          const tr = document.createElement('tr');
          const r = cg.residuals[k] ?? NaN;
          const a = cg.alphas[k] ?? NaN;
          const b = cg.betas[k] ?? NaN;
          tr.innerHTML = `
            <td class="py-1">${k+1}</td>
            <td class="text-right">${fmt(v[0],6)}</td>
            <td class="text-right">${fmt(v[1],6)}</td>
            <td class="text-right">${fmt(v[2],6)}</td>
            <td class="text-right">${fmt(r,3)}</td>
            <td class="text-right">${fmt(a,4)}</td>
            <td class="text-right">${fmt(b,4)}</td>`;
          tbCG.appendChild(tr);
        });
      }
    }

    <script>
// ===================== Presets & Actions =====================
function loadTransport(){
  // Sistema exacto de tu captura:
  // 4 C + 6 M + 8 L = 80
  // 10 C + 20 M + 25 L = 200
  // 5 C + 4 M + 6 L = 100
  const A = [ [4,6,8], [10,20,25], [5,4,6] ];
  const b = [80,200,100];

  setMatrixA(A);
  setVectorB(b);

  // Escalado desactivado
  $('#cbxScale').checked = false;
  toggleScaling(false);
  $('#scaleR1').value = 1;
  $('#scaleR2').value = 1;
  $('#scaleR3').value = 1;

  // Parámetros como en tu panel
  $('#omega').value = 1.00;            // SOR ω
  $('#omegaVal').textContent = '1.00';
  $('#tolSOR').value = 0.001;          // SOR tol
  $('#maxItSOR').value = 1000;         // SOR max it
  $('#tolCG').value = '1e-8';          // CG tol
  $('#maxItCG').value = 1000;          // CG max it
}

function init(){
  buildInputs();
  loadTransport();  // arranca ya con el ejemplo correcto

  $('#btnLoadTransport').addEventListener('click', loadTransport);
  $('#btnClear').addEventListener('click', clearAll);
  $('#btnSolveSOR').addEventListener('click', ()=>{ const sor = solveSOR(); renderAll(sor, null); });
  $('#btnSolveCG').addEventListener('click', ()=>{ const cg = solveCG(); renderAll(null, cg); });
  $('#btnSolveBoth').addEventListener('click', ()=>{ const sor = solveSOR(); const cg = solveCG(); renderAll(sor, cg); });

  $('#omega').addEventListener('input', (e)=> $('#omegaVal').textContent = parseFloat(e.target.value).toFixed(2));
  $('#cbxScale').addEventListener('change', (e)=> toggleScaling(e.target.checked));
}
</script>


    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
